export const enUS = {
  aside: {
    manage: 'Manage',
    connect: 'Connect',
    file: 'File',
    history: 'History',
    github: 'GitHub',
    user: 'User',
    setting: 'Setting',
    chatBot: 'AI Assistant',
    backupRestore: 'Backup/Restore',
  },
  setting: {
    basic: 'Basic',
    theme: 'Theme',
    language: 'Language',
    about: 'About Us',
    auto: 'Follow OS',
    dark: 'Dark Theme',
    light: 'Light Theme',
    ai: {
      title: 'GPTs',
      configGpt: 'Configure GPT',
      others: 'Other GPTs',
      model: 'Model',
      modelPlaceholder: 'Please enter the GPT model name',
      apiKey: 'API Key',
      apiKeyPlaceholder: 'Please enter the API Key',
      prompt: 'Prompt',
      proxy: 'Network Proxy',
      invalid: 'GPT configuration is invalid!',
      missing: 'GPT is not configured or not enabled',
      firstMsg: 'Hello, I am your AI assistant, how can I help you?',
      defaultPrompt: `You are a professional database engineer,
      familiar with the following databases:
        - Elasticsearch
        - OpenSearch
      Current application scenario: Users will ask questions like listing all indices in the database, and provide related index names and mappings.
      Your tasks are:
        - Write Query DSL queries to answer the questions.
        - The Query DSL response should be in a json code block and follow this format:
        \`\`\`json
        <method> <path>
        <Query DSL>
        \`\`\`
        Remove the slash at the start of the path. The body is a JSON object, it's optional and should start as a new line if present. You can use the provided index name and index mapping in the body to answer the question.
        - Do not add extra request parameters unless the user specifies them.
        - Do not add format=json request parameter unless the user specifies the response in JSON format.
        - Answer questions in English unless the user specifies to use another language.
        - If the user asks non-database related questions, politely decline.`,
    },
  },
  manage: {
    cluster: 'CLUSTER',
    nodes: 'NODES',
    shards: 'SHARDS',
    indices: 'INDICES',
    masterNode: 'Master Node',
    masterEligible: 'Master Eligible Node',
    dataNode: 'Data Node',
    ingestNode: 'Ingest Node',
    coordinatingNode: 'Coordinating Node',
    node: {
      ip: 'IP Address',
      heap: 'Heap',
      ram: 'RAM',
      disk: 'Disk',
      shards: 'Shards',
      mappings: 'Mappings',
      statisticTitle: 'Node Statistics',
    },
    index: {
      actions: {
        deleteIndex: 'Delete Index',
        closeIndex: 'Close Index',
        openIndex: 'Open Index',
        removeAlias: 'Remove Alias',
        switchAlias: 'Switch Alias',
        deleteIndexWarning: 'Are you sure you want to delete the index',
        closeIndexWarning: 'Are you sure you want to close the index',
        removeAliasWarning: 'Are you sure you want to remove the alias',
      },
      newIndexForm: {
        title: 'Create Index',
        indexName: 'Index Name',
        shards: 'Number of Shards',
        replicas: 'Number of Replicas',
        bodyJsonRequired: 'Body is not a valid JSON format',
        indexRequired: 'Index name is required',
      },
      newAliasForm: {
        title: 'Create Alias',
        aliasName: 'Alias Name',
        indexName: 'Index Name',
        aliasRequired: 'Alias name is required',
        indexRequired: 'Index name is required',
        filterJsonRequired: 'Filter is not a valid JSON format',
      },
      newTemplateForm: {
        title: 'Create Template',
        indexTemplate: 'Index Template',
        templateName: 'Template Name',
        componentTemplate: 'Component Template',
        templateRequired: 'Template name is required',
        bodyJsonRequired: 'Request Body is not a valid JSON format',
      },
      switchAliasForm: {
        title: 'Switch Alias',
        aliasName: 'Alias Name',
        sourceIndex: 'Source Index',
        targetIndex: 'Target Index',
      },
    },
    emptyDynamodb: 'Still in development',
    emptyNoConnection: 'Please establish connection first',
  },
  connection: {
    new: 'New connection',
    test: 'Test connection',
    name: 'Name',
    host: 'Host',
    port: 'Port',
    username: 'Username',
    password: 'Password',
    indexName: 'Index/Alias',
    queryParameters: 'query parameters',
    sslCertVerification: 'SSL Certificate Verification',
    connectSuccess: 'Connect success',
    deleteSuccess: 'Delete success',
    testSuccess: 'Test connect success',
    saveSuccess: 'Save success',
    edit: 'Edit configuration',
    selectDatabase: 'Please select database type',
    region: 'Region',
    tableName: 'Table Name',
    accessKeyId: 'Access Key ID',
    secretAccessKey: 'Secret Access Key',
    selectRegion: 'Please select region',
    unsupportedType: 'Unsupported database type provided',
    formValidation: {
      nameRequired: 'Name is required',
      tableNameRequired: 'Table name is required',
      hostRequired: 'Host is required',
      portRequired: 'Port is required',
      sslCertOnlyHttps: 'SSL Certificate Verification can only be enabled under HTTPS connection',
      regionRequired: 'Please select region',
      accessKeyIdRequired: 'Please enter Access Key ID',
      secretAccessKeyRequired: 'Please enter Secret Access Key',
    },
    operations: {
      connect: 'Connect',
      edit: 'Edit',
      remove: 'Remove',
    },
    selectIndex: 'No collection/index selected',
    selectConnection: 'No Connection selected',
    validationFailed: 'Form validation failed!',
    unAuthorized: 'Authorization failed, ensure your username and password are correct',
    emptyState: {
      noConnections: 'No connections available',
      pleaseSelect: 'Please select a connection',
    },
    dynamodb: {
      queryComingSoon: 'DynamoDB query interface coming soon...',
      tablesComingSoon: 'DynamoDB tables management coming soon...',
    },
  },
  dialogOps: {
    warning: 'Warning',
    removeNotice: 'Remove the connection permanently?',
    create: 'Create',
    confirm: 'Confirm',
    cancel: 'Cancel',
    removeSuccess: 'removed successfully',
    createSuccess: 'Created successfully',
    deleteSuccess: 'Deleted successfully',
    closeSuccess: 'Closed successfully',
    openSuccess: 'Opened successfully',
    switchSuccess: 'Switched successfully',
    overwriteFile: 'File already exists, do you want to overwrite it?',
    overwriteIndex: 'Index already exists, confirm to overwrite?',
    fileSaveSuccess: 'File saved successfully',
    fileSaveFailed: 'Failed to save file!',
    reset: 'Reset',
    saveAndEnable: 'Save & Enable',
    execute: 'Run',
  },
  editor: {
    establishedRequired: 'Select a DB instance before execute actions',
    invalidJson: 'Invalid JSON format',
    copySuccess: 'Copied to clipboard',
    copyFailure: 'Failed to copy to clipboard',
    unsupportedFile: 'DocKit only supports file end with .search file',
    loadDefault: 'Load default code snippet',
    dynamo: {
      uiQuery: 'Query UI',
      sqlEditor: 'PartiQL Editor',
      tableOrIndex: 'Table/Index',
      selectTableOrIndex: 'Select a Table/Index',
      enterPartitionKey: 'Enter partition key value',
      enterSortKey: 'Enter sort key value',
      filterTitle: 'Filters - Optional',
      inputAttrName: 'Enter attribute name',
      inputOperator: 'Select Operator',
      type: 'Select attribute type',
      inputAttrValue: 'Enter attribute value',
      resultTitle: 'Query Result',
      indexIsRequired: 'Table/Index is required',
      partitionKeyRequired: 'Table/Index Partition key is required',
      atLeastRequired: 'Partition key or at least 1 filter is required',
      scanWarning: 'Request without partitionKey will scan the table',
      createItem: 'Create Item',
      addAttributesTitle: 'Add Attributes',
      attributeNameRequired: 'Attribute name is required',
      attributeTypeRequired: 'Attribute type is required',
      attributeValueRequired: 'Attribute value is required',
      operatorRequired: 'Filter operator is required',
      createItemSuccess: 'Item created successfully!',
      filterLabels: {
        eq: 'Equals',
        ne: 'Not equals',
        lte: 'Less than or equal to',
        lt: 'Less Than',
        gte: 'Greater than or equal to',
        gt: 'Greater than',
        between: 'Between',
        exists: 'Exists',
        notExists: 'Not Exists',
        contains: 'Contains',
        notContains: 'Not Contains',
        beginsWith: 'Begins With',
      },
      partiql: {
        samples: 'Sample Queries',
        sampleSelectPk: 'SELECT with Partition Key',
        sampleSelectSk: 'SELECT with Sort Key',
        sampleScan: 'SCAN (All Items)',
        sampleInsert: 'INSERT Item',
        sampleUpdate: 'UPDATE Item',
        sampleDelete: 'DELETE Item',
        error: 'Query Error',
        noResults: 'Execute a PartiQL query to see results',
        emptyStatement: 'Please enter a PartiQL statement',
        itemsReturned: '{count} items returned',
        loadMore: 'Load More',
      },
    },
  },
  file: {
    newFile: 'New File',
    newFolder: 'New Folder',
    open: 'Open Folder',
    contextMenu: {
      open: 'Open',
      rename: 'Rename',
      delete: 'Delete',
    },
    rename: 'Rename',
    name: 'Name',
    saveFileBeforeClose: {
      title: 'Warning',
      content: 'File does not persist, do you want to save it first?',
      positiveText: 'Save',
      negativeText: 'Delete',
    },
    folderSelectCancel: 'Folder selection canceled',
  },
  history: {
    empty: 'No history yet',
    emptyDesc: 'History of queries will appear here as you execute Scans and Queries',
  },
  backup: {
    backup: 'Backup',
    restore: 'Restore',
    restoreSourceDesc: 'Click or drag a file to this area to upload your JSON/CSV file',
    backupToFileSuccess: 'Successfully backed up to file',
    restoreFromFileSuccess: 'Successfully restored from file',
    backupForm: {
      connection: 'Connection',
      index: 'Index',
      backupFolder: 'Location',
      backupFileName: 'File Name',
      connectionRequired: 'Please select a Connection',
      indexRequired: 'Please select an Index',
      backupFolderRequired: 'Please select Backup Folder',
      backupFileNameRequired: 'Please enter Backup File Name',
      validationFailed: 'Backup Config validation failed!',
      validationPassed: 'Backup Config validation passed!',
      backupFileTypeInvalid: 'Backup file type is invalid',
    },
  },
  version: {
    newVersion: 'New version available',
    message: 'A new version is available, download it now',
    download: 'Download',
    skip: 'Skip this version',
    later: 'Later',
  },
  login: {
    title: 'Log In',
    name: 'User Name',
    password: 'User Password',
    forget: 'Forgot password?',
    register: 'No account? Register Now',
    enterName: 'Please enter one user name',
    enterPwd: 'Please enter password',
  },
  grammar: {
    // Search APIs
    search: 'Execute a search query',
    searchIndex: 'Execute a search query on a specific index',
    count: 'Count documents matching a query',
    countIndex: 'Count documents in a specific index',
    // Document APIs
    indexDoc: 'Index a document',
    getDoc: 'Get, index, or delete a document by ID',
    updateDoc: 'Update a document',
    bulk: 'Perform multiple index/delete/update operations in a single request',
    bulkIndex: 'Perform bulk operations on a specific index',
    // Index APIs
    manageIndex: 'Manage an index',
    indexMapping: 'Get or update index mappings',
    indexSettings: 'Get or update index settings',
    openIndex: 'Open a closed index',
    closeIndex: 'Close an index',
    refreshIndex: 'Refresh an index',
    flushIndex: 'Flush an index',
    forcemergeIndex: 'Force merge an index',
    // Alias APIs
    manageAliases: 'Manage index aliases',
    manageAlias: 'Manage a specific alias',
    // Cat APIs
    catIndices: 'List indices',
    catHealth: 'Cluster health',
    catNodes: 'List nodes',
    catShards: 'List shards',
    catAliases: 'List aliases',
    catTemplates: 'List templates',
    catAllocation: 'Shard allocation',
    // Cluster APIs
    clusterHealth: 'Cluster health',
    clusterState: 'Cluster state',
    clusterStats: 'Cluster stats',
    clusterSettings: 'Cluster settings',
    clusterAllocationExplain: 'Explain shard allocation',
    clusterReroute: 'Reroute shards',
    // Nodes APIs
    nodesInfo: 'Node information',
    nodesStats: 'Node stats',
    nodesHotThreads: 'Hot threads',
    // Template APIs
    indexTemplate: 'Index templates (legacy)',
    indexTemplateComposable: 'Index templates (composable)',
    componentTemplate: 'Component templates',
    // Analyze API
    analyze: 'Analyze text',
    analyzeIndex: 'Analyze text using index analyzer',
    // Validate API
    validateQuery: 'Validate a query',
    // Multi Search API
    multiSearch: 'Execute multiple searches in one request',
    multiSearchIndex: 'Multi search on specific index',
    // Explain API
    explainDoc: 'Explain document scoring',
    // Other APIs
    termsEnum: 'Get matching terms from an index',
    reindex: 'Reindex documents',
    updateByQuery: 'Update documents by query',
    deleteByQuery: 'Delete documents by query',
    listSnapshots: 'List snapshot repositories',
    manageRepository: 'Manage snapshot repository',
    manageSnapshot: 'Manage snapshot',
    restoreSnapshot: 'Restore snapshot',
    listTasks: 'List tasks',
    getTask: 'Get task status',
    cancelTask: 'Cancel task',
    listPipelines: 'List ingest pipelines',
    managePipeline: 'Manage ingest pipeline',
    simulatePipeline: 'Simulate pipeline',
    manageScript: 'Manage stored script',
    fieldCaps: 'Field capabilities',
    fieldCapsIndex: 'Field capabilities for index',
    scroll: 'Scroll search results',
    clearCache: 'Clear cluster cache',
    clearCacheIndex: 'Clear index cache',
    recovery: 'Index recovery status',
    segments: 'Index segments',
    clusterStatsAll: 'Cluster statistics',
    indexStats: 'Index statistics',
    searchShards: 'Search shards routing',
    // Elasticsearch-specific
    eqlSearch: 'EQL search',
    sql: 'SQL query',
    listTransforms: 'List transforms',
    manageTransform: 'Manage transform',
    listDataStreams: 'List data streams',
    manageDataStream: 'Manage data stream',
    listIlmPolicies: 'List ILM policies',
    manageIlmPolicy: 'Manage ILM policy',
    manageRollupJob: 'Manage rollup job',
    manageWatch: 'Manage watch',
    ccrStats: 'CCR stats',
    autoscalingCapacity: 'Autoscaling capacity',
    listAnomalyDetectors: 'List anomaly detection jobs',
    manageAnomalyDetector: 'Manage anomaly detection job',
    listTrainedModels: 'List trained models',
    manageTrainedModel: 'Get or delete trained model',
    inferTrainedModel: 'Infer using trained model',
    listUsers: 'List users',
    manageUser: 'Manage user',
    listRoles: 'List roles',
    manageRole: 'Manage role',
    manageApiKeys: 'Manage API keys',
    // OpenSearch-specific
    pplQuery: 'PPL query',
    listOsAnomalyDetectors: 'List anomaly detectors',
    manageOsAnomalyDetector: 'Manage anomaly detector',
    listAlertingMonitors: 'List alerting monitors',
    manageAlertingMonitor: 'Manage alerting monitor',
    listIsmPolicies: 'List ISM policies',
    manageIsmPolicy: 'Manage ISM policy',
    securityAccount: 'Account information',
    listInternalUsers: 'List internal users',
    manageInternalUser: 'Manage internal user',
    listOsRoles: 'List roles',
    manageOsRole: 'Manage role',
    knnStats: 'k-NN plugin stats',
    knnWarmup: 'Warm up k-NN index',
    asyncSearch: 'Create asynchronous search',
    manageAsyncSearch: 'Get or delete asynchronous search',
    listNotificationChannels: 'List notification channels',
    manageNotificationChannel: 'Manage notification channel',
    listMlModels: 'List ML models',
    manageMlModel: 'Get or delete ML model',
    loadMlModel: 'Load ML model',
    unloadMlModel: 'Unload ML model',
    predictMlModel: 'Predict using ML model',
  },
};
